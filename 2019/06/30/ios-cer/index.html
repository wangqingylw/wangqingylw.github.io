<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>iOS证书介绍 | ckqing.home</title>
  
    <link rel="icon" href="/assets/favicon.jpeg">
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/avatar.jpeg); background-repeat: no-repeat; background-size: cover">
        </div>
    </section>
    <section class='menu'>
        <div>ckqing.home</div>
        
        
            <div>Wang Qing</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="mailto:wq.cyan@gmail.com">
                    <img src="/assets/email.svg" />
                </a>
            
        
            
                <a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCbxLA23tNs25YXY9jZJgq2w">
                    <img src="/assets/youtube.svg" />
                </a>
            
        
            
                <a target="_blank" rel="noopener" href="https://space.bilibili.com/4380662">
                    <img src="/assets/bilibili.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>iOS证书介绍</h1>
    </header>

    <section>
      <h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><p>数字签名</p>
<ul>
<li>代表一个特定的主体(签名者)对特定内容(被签名数据)的署名和认可</li>
<li>签名的本质是用于<code>验证数据的合法性</code>，确保被签名的数据来自特定的来源，并且<code>未经篡改</code>。<ul>
<li>基于<code>非对称加密</code>和<code>哈希算法</code>。</li>
<li>非对称加密<ul>
<li>最常见的公钥加密算法是<code>RSA</code>公钥加密算法</li>
<li>公钥 + 私钥</li>
<li>私钥加密 - 公钥解密（反正亦可，不过一般设定其中一个作为公开的公钥）</li>
</ul>
</li>
<li>哈希算法<ul>
<li>散列、摘要算法</li>
<li>对一段任意长度的数据，通过一定的<code>映射和计算</code>，得到一个<code>固定长度</code>的值，这个值就被称为这段数据的哈希值(<code>hash</code>)。</li>
<li>哈希值不同的两段数据绝对不同 &amp; 相同的数据计算出的哈希值绝对相同</li>
<li>存在碰撞（不同数据段哈希值相同）</li>
<li>哈希算法是<code>单向算法</code>，无法通过哈希值，计算出原始数据。</li>
<li>常见的哈希算法有: <code>md5</code>, <code>sha1</code>, <code>sha256</code>等，其中<code>sha1</code>长度为<code>160bits</code>，而<code>sha256</code>长度为<code>256bits</code></li>
</ul>
</li>
</ul>
</li>
<li>综上，常见的签名算法：<ul>
<li>sha1WithRSAEncryption：先对数据计算sha1摘要，再对摘要进行RSA加密</li>
<li>sha256WithRSAEncryption：先对数据计算sha256摘要，再对摘要进行RSA加密</li>
<li>md5WithRSAEncryption：先对数据计算MD5摘要，再对摘要进行RSA加密</li>
<li>总之一般都是先<code>hash</code>，再<code>RSA</code>。</li>
<li>后续将最终结果统称为<code>加密哈希</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>证书</p>
<ul>
<li>一般会把<code>公钥</code>当做<code>签名(数据签名)</code>的一部分，随着数据一起分发（避免接收方需事先保存各种公钥）</li>
<li>为确保<code>公钥</code>的<code>可信</code>，把<code>公钥</code>和<code>公钥所有者的信息</code>保存在一个文件里，并让一个<code>可信的第三者</code>使用<code>其私钥</code>对这个文件进行<code>签名</code>(证书签名)，得到一个签了名的公钥文件，这个文件就叫做<code>证书</code>。（+外加签发者信息）<ul>
<li><code>证书</code>作为<code>签名</code>的一部分，随着数据一起分发。</li>
<li>若只含 <code>加密哈希</code>（+签发者信息）， 不含 <code>公钥</code>（签发者证书） ，一般称为 <code>简单签名</code></li>
</ul>
</li>
<li>这个<code>可信的第三者</code>就被称为<code>证书颁发机构(Certification Authority)</code>，简称<code>CA</code>。</li>
<li><code>CA的证书</code>可能也是由其他<code>更高一级的CA</code>进行签发，形成<code>多级</code>的<code>证书链</code>，系统中只需保存<code>最高级CA的证书</code>，中间CA的证书和信息提供者的证书依次进行递归校验即可。<ul>
<li>而证书链上的<code>根证书颁发机构(根CA)</code>的证书，是<code>自签名</code>的，被内置在设备中，设备无条件信任</li>
<li><code>根证书(公钥)</code>则由<code>本地</code>持有(不随数据)。</li>
</ul>
</li>
<li>理一理<ul>
<li>数据</li>
<li>数据 + <code>加密哈希(数据)</code></li>
<li>数据 + <code>加密哈希(数据)</code> + 公钥</li>
<li>数据 + <code>加密哈希(数据)</code> + 公钥 + 证书(&#x3D;公钥&amp;公钥所有者信息 + <code>加密哈希(使用签发者公钥可解)</code> + 签发者信息)</li>
<li>其中<ul>
<li><code>加密哈希(签发者公钥)</code> + 签发者信息 &#x3D;&gt; 公钥信息的签名</li>
<li><code>加密哈希(数据)</code> + 公钥 + 证书 &#x3D;&gt; 完整的数据签名</li>
</ul>
</li>
</ul>
</li>
<li>如果涉及<code>多级证书</code><ul>
<li>数据 + <code>加密哈希(数据)</code> + 公钥 + 证书0(&#x3D;公钥&amp;公钥所有者信息 + <code>加密哈希(使用CA1的公钥可解)</code> + CA1的信息 + CA1的证书 (CA2签名) )<ul>
<li>CA1证书&#x3D;CA1公钥&amp;CA1信息 + <code>加密哈希(使用CA2的公钥可解)</code> + CA2的信息 + CA2的证书(CA3签名)</li>
<li>…</li>
<li>CA(n-1)证书&#x3D;CA(n-1)公钥&amp;CA(n-1)信息 + <code>加密哈希(使用CA root的公钥可解)</code> + CA root 信息  （ <code>此时不需要 + CA root 证书</code> ）</li>
</ul>
</li>
<li>系统会检查 <code>CA root</code> 的信息，在本地 <code>keychain</code> 是否有对应的证书（且被信任），并校验即可<ul>
<li>一般情况下， <code>CA root 证书(自签名)</code> 不需要打到证书链</li>
<li><code>CA root 证书</code>&#x3D;CA root公钥&amp;CA root信息 + <code>加密哈希(使用CA root的公钥可解)</code> + CA root 信息<ul>
<li><code>自签名</code>，内置于设备，无条件信任</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>通常说使用<code>证书</code>进行<code>签名</code><ul>
<li>实际指使用与证书所匹配的<code>私钥</code>进行签名，证书作为签名数据的<code>一部分</code>被嵌入签名中。</li>
<li>若Keychain中<code>只有证书</code>，没有对应的<code>私钥文件</code>，则无法进行签名，会得到<code>Missing private key</code>之类的报错。</li>
</ul>
</li>
</ul>
</li>
<li><p>开发者证书</p>
<ul>
<li>一般来说 iOS app 必须<code>被苹果签名</code>之后才能安装到设备上</li>
<li>为方便开发过程中的频繁安装(避免每次都要交给苹果签名)</li>
<li><code>开发者自己</code>持有一套<code>私钥</code>和<code>证书</code></li>
<li>由Apple对开发者的身份进行<code>背书</code>，让设备间能够接信任 <code>开发者自行签名的app</code><ul>
<li><code>背书</code>的方式即 <code>Provisioning Profile</code></li>
</ul>
</li>
<li>普通开发者($99&#x2F;year)<ul>
<li>最大测试uuid支持数：100</li>
<li>按类别分位<code>个人</code>开发者账号和<code>公司</code>开发者账号<ul>
<li>个人： 协作人数1人</li>
<li>公司： 协作人数多人，设置多个Apple ID，分多种管理级别的权限，申请时需要额外信息。</li>
</ul>
</li>
<li>按功能分位<code>Development证书</code>和<code>Distribution证书</code></li>
<li>Development证书<ul>
<li><code>开发及测试阶段</code>使用，一般命名 iPhone Developer: xxxxxxx</li>
<li>用于在设备安装上<code>开发阶段的App</code>后对<code>App的完整性</code>进行校验</li>
<li>如果是多人协作的开发者账号，任意成员都可以申请自己的Development证书。（一般没必要）</li>
</ul>
</li>
<li>Distribution证书<ul>
<li>用于<code>提交AppStore</code>的证书，一般命名 iPhone Distribution: xxxxxxxxx</li>
<li>用于让<code>AppStore</code>校验提交上来的<code>App的完整性</code></li>
<li>只有管理员以上身份的开发者账号才可以申请，<code>不能用于开发及调试</code>。</li>
</ul>
</li>
</ul>
</li>
<li>企业级开发者($299 &#x2F; year)<ul>
<li><code>企业级开发者证书</code></li>
<li>签名的App可以被直接安装在<code>任意的iOS设备</code>上，只要用户<code>主动信任</code>该证书</li>
<li>方便企业给内部员工分发生产力工具</li>
<li>不能发布到 App Store</li>
</ul>
</li>
<li>教育机构：免费、额外申请、不可发布 App Store、 …</li>
</ul>
</li>
<li><p>CSR 文件</p>
<ul>
<li>.certSigningRequest 后缀</li>
<li>Certificate Signing Request</li>
<li>用于向苹果请求证书</li>
<li>包含<ul>
<li><code>个人信息</code>：账号信息</li>
<li><code>公钥</code></li>
<li><code>自签名</code>：使用自己的私钥进行签名</li>
</ul>
</li>
</ul>
</li>
<li><p>.cer证书</p>
<ul>
<li>苹果返回，双击导入 keychain， 与已有公钥、私钥自动配对</li>
<li>签发者：<code>Apple Worldwide Developer Relations Certification Authority</code><ul>
<li><code>中级证书颁发机构(中级CA)</code>，其证书由 <code>Apple Root CA</code> <code>根证书颁发机构(根CA)</code> 进行签发</li>
<li><code>Apple Root CA</code> 的证书，自签名的，被内置在设备中</li>
</ul>
</li>
<li>包含<ul>
<li><code>公钥</code></li>
<li><code>公钥所有者信息</code><ul>
<li>并非由我们自行指定，而是签发者Apple<code>根据我们的账号</code>信息自动生成</li>
</ul>
</li>
<li><code>苹果的签名</code></li>
</ul>
</li>
</ul>
</li>
<li><p>.p12证书</p>
<ul>
<li>个人信息交换文件</li>
<li>Xcode 签名需要</li>
<li>APNs 需要</li>
<li>包含<ul>
<li><code>私钥</code></li>
<li><code>证书</code>（含<code>公钥</code>）</li>
</ul>
</li>
</ul>
</li>
<li><p>推送证书</p>
<ul>
<li>用于和<code>APNs</code>通信的证书</li>
<li>基本同开发者证书</li>
<li>服务端使用<code>推送证书</code>（推送证书的 <code>.p12</code>文件）与APNs通信<ul>
<li><code>每个App</code> 需要单独配置。推送证书的有限期为1年（生产的推送证书比开发的推送证书多一个月），过期之后需要重新配置。</li>
<li>分 <code>开发证书</code> 和 <code>生产证书</code><ul>
<li><code>开发证书</code> 只能用于往开发环境（sandbox）推送消息</li>
<li><code>生产证书</code> 现在可以同时支持开发环境（sandbox）和 生产环境，（以前貌似只能往开发环境推送消息）<ul>
<li>服务端和<code>APNs</code>通信时使用不同的参数区分开发环境（sandbox）和 生产环境</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Entitlements</p>
<ul>
<li>iOS沙盒的<code>配置文件</code>，声明了app所需的<code>权限</code>，如果app中使用到了某项沙盒限制的功能，但没有声明对应的权限，可能运行到相关的代码时会直接Crash。</li>
<li>全新的iOS工程中是没有这个文件的，如果在<code>Capabilities</code>中开启了一些需要权限的功能之后，Xcode会自动(Xcode 8及之后的版本)生成Entilements文件，并将对应的权限声明添加到Entitlements文件中。</li>
<li><code>Capabilities</code> 主要能力如下<ul>
<li>获取 wifi 信息</li>
<li>使用 apple pay</li>
<li>keychain sharing</li>
<li><code>push notifications</code></li>
<li>siri 等等</li>
</ul>
</li>
<li>与 <code>info.plist</code> 的<code>隐私权限</code>配置不同<ul>
<li>相册读写、打开相机、访问日历、访问通讯录等等。</li>
<li>一般情况下，如果没有配，但代码调用了相应的API，提交二进制包就会通不过，苹果会发邮件&#x2F;通知告诉你缺了配置，所以不太担心上线后 crash。（但是提包会失败。）</li>
<li>但有些情况下，是 web 里的某些行为触发的一些逻辑，<ul>
<li>比如 iOS12 下 web 里可以提供上传视频录制的功能，此时会调用<code>麦克风</code>权限，如果此时 APP 没有配置麦克风相关的 <code>隐私权限</code> 描述，就会 crash。</li>
<li>但有时候企业级证书并不 crash…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Provisioning Profile</code></p>
<ul>
<li>官方说明：A provisioning profile is a collection of digital entities that uniquely ties developers and devices to an authorized iPhone Development Team and enables a device to be used for testing.</li>
<li>对<code>设备</code>和<code>开发者</code>授权的作用，他将 <code>开发者账号</code>、<code>证书</code>、<code>entitlements文件</code>以及<code>设备</code>进行了绑定。</li>
<li>Xcode 8及后续版本默认情况下会自动帮我们管理<code>Provisioining Profile</code><ul>
<li>自动下载的<code>Provisioning Profile</code>都被存放在<code>~/Library/MobileDevice/Provisioning\ Profiles/</code>路径下</li>
</ul>
</li>
<li>由<code>Apple iPhone OS Provisioning Profile Signing</code>进行签名</li>
<li>几项关键内容<ul>
<li><code>DeveloperCertificates</code><ul>
<li>允许使用的<code>开发者证书</code>，这是一个列表，一般包含生成这个<code>Provisioning Profile</code>文件时，当前开发者账号下所有有效的<code>Development证书</code></li>
</ul>
</li>
<li><code>Entitlements</code><ul>
<li>允许使用的<code>权限列表</code>，实际在App中使用的权限必须是这个列表的子集，否则安装时会无法通过校验而失败。</li>
</ul>
</li>
<li><code>ProvisionedDevices</code><ul>
<li>允许安装的<code>设备列表</code>，如果目标设备的UUID不在这个列表中，会<code>安装失败</code>。<ul>
<li><code>普通开发者证书</code>: 只允许最多注册100台用于测试的设备，避免任意分发测试包。</li>
<li><code>企业级开发者证</code>: 有任意安装的需求，因此在分发时，这一项会被<code>ProvisionsAllDevices</code>取代，代表授权任意设备。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>这些信息中有任何变动的时候，<ul>
<li>比如开发者证书有新增或者失效，在<code>Capabilities</code>中启用了当前App从未使用过的新功能，</li>
<li>或是将新的iPhone连接到Xcode用于测试，</li>
<li>Xcode都会自动<code>重新申请</code> <code>Provisioning Profile</code>。(前提是<code>Xcode登录</code>了对应的账号，否则还是手工操作吧)</li>
</ul>
</li>
<li><code>Provisioning Profile</code>最终会被<code>内置在App</code>中，置于App根目录下的<code>embedded.mobileprovision</code>。</li>
<li>但从 <code>AppStore</code>上下载下来的App，里面不会有<code>embedded.mobileprovision</code>这个文件，因为经过<code>Apple重新签名</code>以后，设备就不再需要它了。</li>
<li><code>非AppStore</code>安装App时如果签名校验通过，这个文件会<code>自动被拷贝</code>到iOS设备的&#x2F;Library&#x2F;MobileDevice&#x2F;Provisioning\ Profiles&#x2F;路径下。</li>
<li>由于该文件已被<code>Apple官方</code>签名，系统可以无条件信任它，并用它来校验<code>App的签名</code>、<code>权限</code>，以及<code>本机的UUID</code>等是否满足来自官方的授权。</li>
<li>通过这种方式，<code>间接信任</code>了使用<code>开发者证书签名的App</code>，让iOS设备可以运行非苹果官方签名的App。</li>
</ul>
</li>
</ul>
<h2 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h2><ul>
<li><p>2008年苹果发布iOS2.0时引入了强制代码签名(Mandatory Code Signing)</p>
<ul>
<li>严格控制设备上能够运行的代码</li>
<li>为iOS设备的安全性和苹果的AppStore生态奠定了坚实的基础。</li>
<li>iOS的代码签名是典型的<code>数字签名</code></li>
</ul>
</li>
<li><p>好处：</p>
<ul>
<li>安全性<ul>
<li>保证设备及系统的安全性<ul>
<li>只有被苹果设备认可的证书签名的代码才能够被执行，否则在安装或者运行时会因为无法通过内核的签名校验而失败。</li>
<li>iOS的系统中内置了来自苹果的CA证书，系统自身的代码都是被苹果签名过的， 而用户从AppStore下载的App也都已被苹果官方进行签名。</li>
<li>签名机制可以有效地防止来自外部的攻击。</li>
</ul>
</li>
<li>保障沙盒的有效运转，有效地限制app的行为<ul>
<li>沙盒的配置是绑定在签名中的，即<code>Entitlements</code>文件，也是强制签名保护的对象。</li>
</ul>
</li>
</ul>
</li>
<li>分发控制<ul>
<li>苹果拥有App分发的绝对控制权。</li>
<li>在iOS平台上(面向未越狱的用户)公开发行App的合法途径有且只有一种，就是上传到苹果官方的<code>AppStore</code>供用户下载。<ul>
<li>苹果会进行严格的<code>审查</code>并<code>签名</code></li>
<li>企业包需要申请企业证书进行签名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在编译<code>iOS App</code>时，Xcode在编译的打包的流程中会<code>自动进行</code>代码签名</p>
<ul>
<li>可以在编译日志界面找到一个<code>Sign</code>的步骤，内部是调用了<code>codesign</code>命令</li>
</ul>
</li>
<li><p>Xcode 签名后的差异（对比无签名状态）</p>
<ul>
<li>多了一个<code>_CodeSignature文件夹</code>，只有一个文件<code>CodeResources</code><ul>
<li>plist文件，保存签名时<code>每个文件</code>（<code>除了App的可执行文件</code>）的<code>明文哈希值</code>(单纯<code>哈希</code>，未<code>加密</code>)<ul>
<li>这里的<code>哈希值</code>是<code>哈希</code>之后再<code>base64编码</code>的明文，并没有用私钥加密</li>
</ul>
</li>
<li>有<code>files</code>和<code>files2</code> 两个部分，分别是旧版本和新版本的文件列表，<ul>
<li>用<code>rules</code>与<code>rules2</code>两个部分描述了新旧版本计算hash时需要<code>被排除的文件</code>以及每个<code>文件的权重</code>。</li>
<li><code>files</code>中保存的是每个文件的<code>sha1</code>值，<code>files2</code>中同时保存了<code>sha1</code>和<code>sha256</code>。</li>
</ul>
</li>
</ul>
</li>
<li>多了一个<code>embedded.mobileprovision</code>文件<ul>
<li>即对应的<code>Provisioning Profile</code>文件，直接拷贝到了app的根目录并重命名</li>
</ul>
</li>
<li><code>二进制文件</code>内容有差异，签名后体积变大<ul>
<li>签名后二进制文件多了一个名为<code>LC_CODE_SIGNATURE</code>的<code>Load Command</code>，即代码签名</li>
<li>代码签名是一段纯二进制的数据，（具体结构定义详见苹果官方文档），其中包含如下内容<ul>
<li>Code Directory (旧版本， <code>sha1</code>)</li>
<li>Requirements</li>
<li>Entitlements</li>
<li>Code Directory (新版本， <code>sha256</code>)</li>
<li>CMS Signature</li>
</ul>
</li>
<li><code>Code Directory</code>里面是<code>整个MachO文件</code>的哈希值<ul>
<li>但<code>不是</code>一次性对<code>整个文件</code>进行哈希</li>
<li>而是将MachO文件按照<code>pageSize</code>(一般是4k即4096字节)进行分页，每一页单独计算哈希(单纯<code>哈希</code>，未<code>加密</code>)，并按顺序保存。</li>
<li>有两个<code>Code Directory</code>，除哈希类型，其他内容基本一样</li>
<li>文件不一定是<code>pageSize</code>的整数倍，最后一页往往不足，用额外的字段<code>codeLimit</code>记录文件的实际大小<ul>
<li>通过这个值算出最后一页的实际大小，并提取相应数据计算最后一页的签名。</li>
</ul>
</li>
<li>除<code>MachO</code>外，在第一页的前面，还有5个特殊的负数页，用来保存以下这些额外信息的哈希值。(也是单纯<code>哈希</code>，未<code>加密</code>)<ul>
<li>-1 App根目录的Info.plist文件</li>
<li>-2 Requirements（代码签名的第二部分）</li>
<li>-3 Resource Directory (_CodeSignature&#x2F;CodeResources文件)</li>
<li>-4 暂未使用</li>
<li>-5 Entitlements (代码签名的第三部分)</li>
</ul>
</li>
</ul>
</li>
<li><code>Requirements</code><ul>
<li>用于指定签名校验时的一些额外的约束，签名时codesign命令会自动生成这部分数据，细节忽略，官方文档有一些描述</li>
</ul>
</li>
<li><code>Entitlements</code><ul>
<li>整个被嵌入到签名数据中</li>
<li>但不是工程中原始的，Xcode混合上一些默认的参数信息生成的。</li>
</ul>
</li>
<li><code>CMS Signature</code><ul>
<li>最重要的部分</li>
<li><code>Cryptographic Message Syntax</code>，一种标准的签名格式，和<code>Provisioning Profile</code>的签名格式相同</li>
<li>内容包括但不限于：<ul>
<li>证书链：包含用于签名的开发者证书及所有上游CA的证书</li>
<li>签名者信息</li>
<li>哈希算法</li>
<li>签名算法（对哈希值进行加密所使用的算法）</li>
<li><code>加密后的哈希值</code></li>
<li><code>signedAttrs</code>字段<ul>
<li>需要签名的属性, 是<code>可选项</code>，</li>
<li><code>为空</code>表示被签名的数据是<code>原始文件</code>的内容，</li>
<li>如果不为空则至少要包含<code>原始文件的类型</code>以及其<code>哈希值</code>，此时被签名的数据就是signedAttrs的内容</li>
<li>先计算被签名数据的<code>哈希</code>，然后再对哈希值进行<code>签名</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>Code Directory</code>的<code>哈希值CDHash</code>作为数据记录在<code>signedAttrs</code>中，作为最终真正被<code>签名(计算哈希+加密)</code>的内容。<ul>
<li><code>signedAttrs</code> 中再对 <code>CDHash</code> 进行 <code>签名(计算哈希+加密)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>总结一波加密数据情况<ul>
<li><code>_CodeSignature/CodeResources</code>中对每个资源文件计算哈希</li>
<li>二进制中 <code>Code Directory</code> 中对<code>MachO</code>文件本身的每个分页，以及<code>Info.plist</code>、<code>CodeResources</code>、<code>Entitlements</code>等文件计算哈希</li>
<li>计算 <code>Code Directory</code>的<code>哈希CDhash</code>，存储在二进制中 <code>CMS Signature</code>的<code>signedAttrs</code>中</li>
<li>二进制中 <code>CMS Signature</code>的<code>signedAttrs</code>再对<code>signedAttrs</code>进行 <code>签名</code>(计算<code>哈希</code>并使用开发者的<code>私钥</code>加密)</li>
</ul>
</li>
<li>只有最后一步的涉及<code>真正加密</code>， 前面几步的均为单纯，只要任意内容有变化，均会因某个环节的哈希不匹配而导致签名校验的失败。</li>
</ul>
</li>
<li><p>导出 or 提交App</p>
<ul>
<li>在Xcode Organizer中导出或者提交App时，Xcode会将<code>Entitlements</code>文件及<code>embedded.mobileprovision</code>文件替换为<code>对应的版本</code></li>
<li>并使用对应的证书<code>重新签名</code><ul>
<li>AppStore：不可调试，推送为<code>生产环境</code>，无ProvisionedDevices，<code>发布证书</code></li>
<li>Ad Hoc：不可调试，推送为<code>生产环境</code>，允许安装到已注册的测试设备，<code>发布证书</code></li>
<li>Development：可调试，推送为<code>测试环境</code>，允许安装到已注册的测试设备，<code>开发证书</code></li>
<li>Enterprise：不可调试，推送为<code>生产环境</code>，ProvisionAllDevices，<code>企业级发布证书</code></li>
</ul>
</li>
</ul>
</li>
<li><p>App 安装时</p>
<ul>
<li>由<code>/usr/libexec/installd</code>完成</li>
<li><code>installd</code>会通过<code>libmis.dylib</code>校验<code>ProvisioningProfile</code>、<code>Entitlements</code>及签名的合法性<ul>
<li>递归地校验签名时每一个步骤生成的哈希值：<code>CDHash</code>, <code>Code Directory</code>, <code>_CodeSignature/CodeResources</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>App 启动时</p>
<ul>
<li><code>loader</code>会先将可执行文件加载到虚拟内存，在加载的过程中<code>mach_loader</code>会自动解析<code>MachO</code>文件中的<code>LC_CODE_SIGNATURE</code>并进行校验</li>
<li><code>load_code_signature</code>在解析完签名的数据后会调用<code>mac_vnode_check_singature</code>函数进行验证<ul>
<li>最终也是调用了<code>libmis.dylib</code>来实现签名的校验，这一校验过程基本与安装时一致，防止安装后的篡改。</li>
</ul>
</li>
<li>加载过程中为了提升加载效率，签名校验并不会去检查<code>Code Directory</code>与<code>实际的代码</code>是否匹配，仅检查了<code>CMS Signature</code>及<code>Code Directory Hash</code>的合法性。</li>
</ul>
</li>
<li><p>APP 运行时</p>
<ul>
<li>当<code>一页代码</code>被加载到虚拟内存后，会立即触发<code>page fault</code>，会判断代码页<code>是否需要签名校验</code></li>
<li>如果需要，则计算当前代码页的哈希值，并与签名中<code>Code Directory</code>记录的值进行比对。如果不符，且不满足系统预设的<code>例外条件</code>，则会向内核发出CS_KILL指令。</li>
</ul>
</li>
<li><p>有关越狱</p>
<ul>
<li>越狱之后，签名<code>校验机制</code>会被破坏掉。</li>
<li>在iOS6&#x2F;7时代，典型的方式是替换 <code>libmis.dylib</code>中的<code>_MISValidateSignature</code>函数，使其永远返回验证成功，简单粗暴。</li>
<li>这样既可在沙盒范围内，声明任意的权限。</li>
</ul>
</li>
<li><p>重签名</p>
<ul>
<li>有时出于各种原因，我们需要对一个App进行<code>重签名</code>，方便在自己的设备上进行测试。</li>
<li>需要使用和原App相同或者至少包含原App所需权限的<code>Entitlements</code>文件</li>
<li><code>Entitlements</code>文件中还有一些跟<code>Team ID</code>和<code>App ID</code>相关的配置<ul>
<li>因为我们不能使用已经被其他开发者注册过的ID。使用自己的ID一般也不会有什么问题，但在某些情况下可能导致最终的程序逻辑出现异常，这根具体的代码实现细节有关。</li>
<li>正常签名的App中，<code>Entitlements</code>文件中标识的<code>application-identifier</code>（<code>Bundle ID</code>）和<code>Info.plist</code>中的<code>CFBundleIdentifier</code>的值是相同的，</li>
<li>但实际在签名校验过程中，系统<code>不检查</code>二者是否一致，所以即使不一致，也不影响重签名之后的运行。</li>
</ul>
</li>
<li>只要确保有正确的<code>Entitlements</code>，<code>Provisioning Profile</code>与<code>Entitlements</code>匹配，且包含重签时使用的<code>证书</code>及目标设备的UUID，就可以进行重签名了</li>
<li>另需要注意，App中除了可执行程序文件外，还会可能会有<code>Frameworks</code>及<code>Plugins</code>，里面都会包含二进制的代码文件，他们的<code>哈希值</code>也会被存储在 <code>_CodeSignature/CodeResources</code> 中。所有的<code>二进制代码</code>都必须进行签名，而签名后<code>二进制文件</code>的哈希值就会产生变化，因此需要先对这两个文件夹下的二进制文件进行签名，再对<code>App</code>进行签名。</li>
<li>（有各种现成的工具可以重签名）</li>
</ul>
</li>
</ul>
<h2 id="有关-APNs"><a href="#有关-APNs" class="headerlink" title="有关 APNs"></a>有关 APNs</h2><ul>
<li><p>Apple Push Notification service</p>
</li>
<li><p>苹果推送通知服务</p>
</li>
<li><p>服务端两种认证方式</p>
<ul>
<li>基于证书的信任认证（旧版，更常用一些）<ul>
<li>服务端使用<code>推送证书</code>（推送证书的 <code>.p12</code>文件）与APNs通信</li>
<li><code>每个App</code> 需要单独配置。推送证书的有限期为1年（生产的推送证书比开发的推送证书多一个月），过期之后需要重新配置。</li>
<li>现在的<code>生产推送证书</code>已经可以同时支持 sandbox 和 生产环境。</li>
</ul>
</li>
<li>基于Token的信任认证（新版，2016年）<ul>
<li>在开发者平台申请<code>APNs Auth Key</code>，得到包含 <code>APNs Auth Key</code>的<code>.p8</code>密钥文件。</li>
<li><code>.p8</code> 文件只能<code>下载一次</code></li>
<li>服务端使用包含token(<code>APNs Auth Key</code>)的<code>.p8</code>文件与APNs通信</li>
<li>一个认证密钥可用于同一个账号下<code>多个App</code>服务，而且<code>永远不过期</code>，可以重新申请，使旧的失效。</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器与 APNs 通信的时候，必须实现上述两种认证方式之一</p>
</li>
<li><p><code>device token</code></p>
<ul>
<li>是一个不透明的<code>NSData</code>，包含<code>一个设备</code>上的<code>一个应用</code>的唯一标识。</li>
<li>只有 APNs 能解密并查看 <code>device token</code> 中的内容。</li>
<li>APNs 提供的 <code>device token</code> 的<code>长度不定</code>，不要强行解码其大小</li>
</ul>
</li>
<li><p>大概的流程</p>
<ul>
<li>APP 安装</li>
<li>APP 启动，APP 向 <code>APNs</code> 发送<code>远程推送注册请求</code></li>
<li>苹果给 APP 提供唯一的 <code>device token</code><ul>
<li>回调方法 <code>application:didRegisterForRemoteNotificationWithDeviceToken:</code></li>
</ul>
</li>
<li>APP 将自己的 <code>device token</code> 转发给自己的 <code>服务端</code><ul>
<li>一般按二进制或十六进制的格式发给你的服务器</li>
</ul>
</li>
<li><code>服务端</code> 做好相应的记录</li>
<li><code>服务端</code> 要发送推送消息时，使用 <code>推送证书</code> + <code>device token</code> + <code>推送内容</code> 来发送消息</li>
<li>APNs 进行校验，通过后，会向<code>设备</code>发送请求的推送信息</li>
<li><code>设备</code> 接收到 APNs 发来的推送之后，<code>操作系统</code> 会把通知递送给相应的 APP。</li>
</ul>
</li>
<li><p>一般情况下如果设备已经注册了<code>远程推送请求</code>，并且特定 APP 的 <code>device token</code> 并没有变化，则 APNs 会返回<code>已经存在</code>的 <code>device token</code> 到设备上</p>
</li>
<li><p>APNs 下发新的 <code>device token</code> 可能的原因：</p>
<ul>
<li>用户安装你的APP到<code>新设备</code>上</li>
<li>用户通过备份<code>恢复设备</code></li>
<li>用户重装系统后</li>
<li>其它系统层面的事件</li>
</ul>
</li>
<li><p>所以，一般APP在启动的时候必须请求<code>device token</code></p>
</li>
</ul>
<h2 id="简单实地操作"><a href="#简单实地操作" class="headerlink" title="简单实地操作"></a>简单实地操作</h2><ul>
<li><p>Apple ID</p>
<ul>
<li>注册</li>
</ul>
</li>
<li><p>开发者账号</p>
<ul>
<li>提交信息+交钱</li>
<li>购买$99（¥688） &#x2F; $299</li>
<li>如果要公司或企业级，还需要提供邓白氏编码等信息，等苹果联系等等</li>
</ul>
</li>
<li><p>登录苹果开发者平台</p>
</li>
<li><p>创建 APP ID</p>
<ul>
<li>根据引导，填写各种信息</li>
</ul>
</li>
<li><p>创建证书（开发）</p>
<ul>
<li>Mac - 钥匙串访问 - 证书助理 - 从证书颁发机构请求证书</li>
<li>填写<code>开发者账号</code>的邮箱，存储到磁盘即可 -&gt; 生成 CSR（certSigningRequest）<ul>
<li><code>开发证书</code>、<code>发布证书</code>、<code>Push 证书</code>，都需要各弄一个 CSR</li>
<li>此时本地已经生成了对应的 公钥 + 私钥</li>
</ul>
</li>
<li>开发者平台 - Certifications，根据引导，选择对应的类型，上传 CSR，下载 Cer 文件</li>
<li>双击安装，导入钥匙链， 自动与 CSR 对应的关联</li>
</ul>
</li>
<li><p>创建配置文件（描述文件Provisioning Profile）</p>
<ul>
<li>开发者平台 - Provisioning Profile，根据引导，<ul>
<li>选择对应的类型</li>
<li>选择 APP ID</li>
<li>选择证书</li>
<li>选择设备</li>
<li>取个名字</li>
<li>Generate</li>
<li>Download</li>
</ul>
</li>
<li>双击就添加到 Xcode 中</li>
<li>也可以在Xcode中下载（当然，前提是登陆了对应的账号）<ul>
<li>Xcode - Preference - Accounts</li>
<li>即可管理相应的证书</li>
</ul>
</li>
</ul>
</li>
<li><p>创建 APP</p>
<ul>
<li>选择对应的 APP ID</li>
<li>填写 APP 信息<ul>
<li>记得现在需要隐私说明了</li>
</ul>
</li>
</ul>
</li>
<li><p>Xcode -&gt; 创建项目</p>
</li>
<li><p>Project -&gt; Build Setting</p>
<ul>
<li>Signing<ul>
<li>Code Signing Identity<ul>
<li>证书配置<ul>
<li>Debug</li>
<li>Release</li>
<li>ReleaseInHouse（企业级证书）</li>
</ul>
</li>
<li>Provisioning Profile<ul>
<li>对应配置</li>
<li>也可以配置成 automatic，然后在 TARGETS 里配置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TARGETS -&gt; General</p>
<ul>
<li>Identity<ul>
<li>Bundle Identifier: 即 Bundle Id</li>
</ul>
</li>
<li>Siging</li>
<li>Sining(Debug):  选择<code>Development</code>开发证书对应的 Provisioning Profile</li>
<li>Sining(Relase): 选择<code>Distribution</code>发布证书对应的 Provisioning Profile</li>
</ul>
</li>
<li><p>debug 打包</p>
<ul>
<li>Xcode 点击 Run</li>
</ul>
</li>
<li><p>导出 ad hoc 或上传 App Store</p>
<ul>
<li>Product - Archive<ul>
<li>需要有<code>Distribution</code>发布证书以及对应的<code>Provisioning Profile</code>，才能执行<code>Archive</code></li>
</ul>
</li>
<li>生成的文件可以在 Window - Organizer 中的 <code>Archives</code> tab 中找到（<code>Archive</code>执行完毕后会自动打开）</li>
<li>可以进行导出 <code>ad hoc</code> 包，或者上传 <code>AppStore</code> 等操作<ul>
<li>也可以在 Xcode - Open Developer Tool - Application Loader 来进行相关上传操作</li>
</ul>
</li>
</ul>
</li>
<li><p>相关打包、上传等操作，可以通过 xcode 提供的命令行工具进行操作，可以手工指定各种参数、证书所在位置、证书ID等，方便的进行持续集成、自动化打包等工作。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://xelz.info/blog/2019/01/11/ios-code-signature/">深度长文：细说iOS代码签名</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/16fa56eacb5e">史上最用心的iOS App上架流程</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/cn/support/certificates/">苹果-支持-证书</a></li>
<li><a target="_blank" rel="noopener" href="http://www.kuqin.com/shuoit/20151216/349477.html">漫谈iOS程序的证书和签名机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7b0b7b6b011b">iOS 各种证书及描述文件过期或revoke的影响</a></li>
<li><a target="_blank" rel="noopener" href="https://lion1ou.win/2016/07/28/">iOS开发者账号区分详解</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012019282">苹果远程推送通知 APNs 详解，官方，iOS | Swift | UNNotification</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/abd3c55db48e?from=timeline&isappinstalled=0">细谈证书与Provisioning Profile</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7c9678704ae2">iOS 两种推送方式</a></li>
</ul>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2019-06-30T04:46:56.000Z" itemprop="datePublished">
              2019-06-30
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/iOS/">iOS</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/certificate/">certificate</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2022 - Wang Qing </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>